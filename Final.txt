#include <GL/gl.h>
#include <GL/glut.h>
#include <cstdlib>
#include <cmath>
int windowWidth = 1920;
int windowHeight = 1080;
int numBubbles = 20;
float bubbleRadius = 20.0;
float bubbleSpeed = 1.0;
float bubblePositionX[100];
float bubblePositionY[100];
float fishPosX = 50.0; // Initial X position of the fish
float fishPosX2 = windowWidth-50; // Initial X position of the fish2
float jellyPosY = 100;
float x_cor = 1080;
int jellyCounter = 0;
void jellyfish()
{
    float scalingFactor = 15; // Adjust this value to make the jellyfish bigger or smaller

    // JellyFish Body
    glColor3f(1.0, 0.5, 0.8); // Fancy color (pinkish)
    glBegin(GL_POLYGON);
    glVertex2f(5.9348448602658 * scalingFactor + x_cor, 9.8338256504978 * scalingFactor + jellyPosY);
    glVertex2f(5.0173194818357 * scalingFactor + x_cor, 9.7213785329573 * scalingFactor + jellyPosY);
    glVertex2f(4.3528592418237 * scalingFactor + x_cor, 9.2715900627953 * scalingFactor + jellyPosY);
    glVertex2f(3.851958445507 * scalingFactor + x_cor, 8.484460240012 * scalingFactor + jellyPosY);
    glVertex2f(3.5452844885784 * scalingFactor + x_cor, 7.499007862251 * scalingFactor + jellyPosY);
    glVertex2f(4.1279650067427 * scalingFactor + x_cor, 7.5285701249633 * scalingFactor + jellyPosY);
    glVertex2f(5.17427742399 * scalingFactor + x_cor, 7.4189975691832 * scalingFactor + jellyPosY);
    glVertex2f(5.9348448602658 * scalingFactor + x_cor, 7.4132305925632 * scalingFactor + jellyPosY);
    glEnd();

    glColor3f(0.8, 0.5, 1.0); // Fancy color (purplish)
    glBegin(GL_POLYGON);
    glVertex2f(5.9348448602658 * scalingFactor + x_cor, 9.8338256504978 * scalingFactor + jellyPosY);
    glVertex2f(6.8573632234072 * scalingFactor + x_cor, 9.7213785329573 * scalingFactor + jellyPosY);
    glVertex2f(7.5116009981883 * scalingFactor + x_cor, 9.2409226671025 * scalingFactor + jellyPosY);
    glVertex2f(8.012501794505 * scalingFactor + x_cor, 8.46401530955 * scalingFactor + jellyPosY);
    glVertex2f(8.3079247164197 * scalingFactor + x_cor, 7.499007862251 * scalingFactor + jellyPosY);
    glVertex2f(7.7467176985002 * scalingFactor + x_cor, 7.5285701249633 * scalingFactor + jellyPosY);
    glVertex2f(6.7040262449429 * scalingFactor + x_cor, 7.4189975691832 * scalingFactor + jellyPosY);
    glVertex2f(5.9348448602658 * scalingFactor + x_cor, 7.499007862251 * scalingFactor + jellyPosY);
    glEnd();

    glColor3f(0.7, 0.4, 0.9); // Fancy color (lavender)
    glBegin(GL_POLYGON);
    glVertex2f(3.5452844885784 * scalingFactor + x_cor, 7.5644383692262 * scalingFactor + jellyPosY);
    glVertex2f(3.3825360815292 * scalingFactor + x_cor, 7.1197290810414 * scalingFactor + jellyPosY);
    glVertex2f(3.5294472025071 * scalingFactor + x_cor, 6.9186928102296 * scalingFactor + jellyPosY);
    glVertex2f(3.8387337729868 * scalingFactor + x_cor, 6.8491033318716 * scalingFactor + jellyPosY);
    glVertex2f(4.5578250493523 * scalingFactor + x_cor, 7.1119969167794 * scalingFactor + jellyPosY);
    glVertex2f(5.2034674552142 * scalingFactor + x_cor, 6.7797545149297 * scalingFactor + jellyPosY);
    glVertex2f(5.9264181237254 * scalingFactor + x_cor, 7.0656039312075 * scalingFactor + jellyPosY);
    glVertex2f(6.7040262449429 * scalingFactor + x_cor, 7.4928811126095 * scalingFactor + jellyPosY);
    glEnd();

    glColor3f(0.6, 0.3, 0.8); // Fancy color (purple)
    glBegin(GL_POLYGON);
    glVertex2f(5.1865928162797 * scalingFactor + x_cor, 7.4956199863057 * scalingFactor + jellyPosY);
    glVertex2f(5.9264181237254 * scalingFactor + x_cor, 7.0656039312075 * scalingFactor + jellyPosY);
    glVertex2f(6.6455094000909 * scalingFactor + x_cor, 6.7717816892517 * scalingFactor + jellyPosY);
    glVertex2f(7.2983721582929 * scalingFactor + x_cor, 7.1130892370081 * scalingFactor + jellyPosY);
    glVertex2f(7.9909059816779 * scalingFactor + x_cor, 6.8568354961336 * scalingFactor + jellyPosY);
    glVertex2f(8.3673621974261 * scalingFactor + x_cor, 6.9296840832352 * scalingFactor + jellyPosY);
    glVertex2f(8.4721651424391 * scalingFactor + x_cor, 7.1550104150133 * scalingFactor + jellyPosY);
    glVertex2f(8.3079247164197 * scalingFactor + x_cor, 7.5644383692262 * scalingFactor + jellyPosY);
    glEnd();

    glColor3f(0.5, 0.2, 0.7); // Fancy color (dark purple)
    glBegin(GL_POLYGON);
    glVertex2f(4.5578250493523 * scalingFactor - 20 + x_cor, 7.1119969167794 * scalingFactor + jellyPosY);
    glVertex2f(4.6013728757244 * scalingFactor - 20 + x_cor, 6.7493970157177 * scalingFactor + jellyPosY);
    glVertex2f(4.2747910056077 * scalingFactor + x_cor, 6.2316452704107 * scalingFactor + jellyPosY);
    glVertex2f(4.983712626105 * scalingFactor + x_cor, 6.3909534997359 * scalingFactor + jellyPosY);
    glVertex2f(5.93159659059 * scalingFactor + x_cor, 6.0086137493554 * scalingFactor + jellyPosY);
    glVertex2f(5.9264181237254 * scalingFactor + x_cor, 7.0656039312075 * scalingFactor + jellyPosY);
    glVertex2f(4.5578250493523 * scalingFactor + x_cor, 7.1119969167794 * scalingFactor + jellyPosY);
    glEnd();

    glColor3f(0.4, 0.1, 0.6); // Fancy color (dark purple)
    glBegin(GL_POLYGON);
    glVertex2f(5.9264181237254 * scalingFactor + x_cor, 7.0656039312075 * scalingFactor + jellyPosY);
    glVertex2f(5.93159659059 * scalingFactor + x_cor, 6.0086137493554 * scalingFactor + jellyPosY);
    glVertex2f(6.8954113780076 * scalingFactor + x_cor, 5.8062015054959 * scalingFactor + jellyPosY);
    glVertex2f(7.9840067143846 * scalingFactor + x_cor, 6.0803051942225 * scalingFactor + jellyPosY);
    glVertex2f(8.9185521901107 * scalingFactor + x_cor, 6.3816781461181 * scalingFactor + jellyPosY);
    glVertex2f(8.8165594743617 * scalingFactor + x_cor, 7.1550104150133 * scalingFactor + jellyPosY);


    glEnd();
    glColor3f(0.2, 0.8, 0.4); // Fancy color (green)
    for (float x = 4.6268621924165 * scalingFactor + x_cor; x <= 7.2904957867342 * scalingFactor + x_cor; x += 0.2365727205 * scalingFactor)
    {
        glBegin(GL_LINES);
        glVertex2f(x, 6.2977581855807 * scalingFactor + jellyPosY); // Tentacle starting point
        glVertex2f(x, 3.8006016909079 * scalingFactor + jellyPosY);
        glEnd();
    }

    glFlush();
}


void fish2(int pos)
{

    glColor3f(1.0, 0.0, 0.5); // Fancy color (pinkish)
    glBegin(GL_POLYGON);
    glVertex2f(3.3367370835797 * 11+fishPosX2, 7.0145439628335 * 11 + pos);
    glVertex2f(5.9275065298185 * 11+fishPosX2, 8.1342923482976 * 11 + pos);
    glVertex2f(10.6935727078222 * 11+fishPosX2, 8.13429234829 * 11 + pos);
    glVertex2f(13.2380532578832 * 11+fishPosX2, 7.0145439628335 * 11 + pos);
    glVertex2f(10.6935727078222 * 11+fishPosX2, 6.1324138284434 * 11 + pos);
    glVertex2f(5.9275065298185 * 11+fishPosX2, 6.1324138284434 * 11 + pos);
    glVertex2f(3.3367370835797 * 11+fishPosX2, 7.0145439628335 * 11 + pos);
    glEnd();

    // Fish tail
    glBegin(GL_POLYGON);
    glVertex2f(13.2380532578832 * 11+fishPosX2, 7.0145439628335 * 11+ pos);
    glVertex2f(14.6 * 11+fishPosX2, 8.4 * 11+ pos);
    glVertex2f(14.1682052819829 * 11+fishPosX2, 7.0145439628335 * 11+ pos);
    glVertex2f(14.6 * 11+fishPosX2, 5.8 * 11+ pos);
    glVertex2f(13.2380532578832 * 11+fishPosX2, 7.0145439628335 * 11+ pos);
    glEnd();

    // Eye
    const float eyeRadius = 0.3 * 11;
    const int numSegments = 50;
    const float angleIncrement = 2.0 * M_PI / numSegments;
    const float centerX = 5.432516609874 * 11+fishPosX2;
    const float centerY = 7.2299742010855 * 11+ pos;

    glColor3f(1.0, 1.0, 1.0); // White color
    glBegin(GL_POLYGON);
    for (int i = 0; i < numSegments; ++i)
    {
        float angle = i * angleIncrement;
        float x = centerX + eyeRadius * cos(angle);
        float y = centerY + eyeRadius * sin(angle);
        glVertex2f(x, y);
    }
    glEnd();

    // Fins
    glColor3f(0.0, 1.0, 1.0); // Cyan color
    glBegin(GL_TRIANGLES);
    glVertex2f(6.4015607510735 * 11+fishPosX2, 8.1342923482976 * 11+ pos);
    glVertex2f(7.0741489011767 * 11+fishPosX2, 9.0252912175314 * 11+ pos);
    glVertex2f(7.0863057373307 * 11+fishPosX2, 8.1342923482976 * 11+ pos);
    glEnd();

    glBegin(GL_TRIANGLES);
    glVertex2f(6.4191183148237 * 11+fishPosX2, 6.1324138284434 * 11+ pos);
    glVertex2f(7.0687481735805 * 11+fishPosX2, 5.693790987022 * 11+ pos);
    glVertex2f(7.0863057373307 * 11+fishPosX2, 6.1324138284434 * 11+ pos);
    glEnd();

    glBegin(GL_TRIANGLES);
    glVertex2f(9.1405406961022 * 11+fishPosX2, 8.1342923482976 * 11+ pos);
    glVertex2f(9.8055456071312 * 11+fishPosX2, 8.5782083807511 * 11+ pos);
    glVertex2f(10.2805711212103 * 11+fishPosX2, 8.1342923482976 * 11+ pos);
    glEnd();

    // Mouth
    glColor3f(1.0, 0.0, 0.0); // Red color
    glBegin(GL_LINES);
    glVertex2f(6.0092761705584 * 11+fishPosX2, 7.6589715264465 * 11+ pos);
    glVertex2f(6.2568421167704 * 11+fishPosX2, 7.4353635750291 * 11+ pos);
    glVertex2f(6.2568421167704 * 11+fishPosX2, 7.4353635750291 * 11+ pos);
    glVertex2f(6.2648281150353 * 11+fishPosX2, 7.0280776635189 * 11+ pos);
    glEnd();

    // Line on the mouth
    glColor3f(1.0, 0.5, 1.0); // Magenta color
    glBegin(GL_LINES);
    glVertex2f(6.2568421167704 * 11+fishPosX2, 7.4353635750291 * 11+ pos);
    glVertex2f(6.2648281150353 * 11+fishPosX2, 7.0280776635189 * 11+ pos);
    glEnd();

    glFlush();
}


void fish1(int s) {
   // Triangle 1
   glColor3f(0.39, 0.58, 0.93); // Light blue
   glBegin(GL_TRIANGLES);
   glVertex3f(20.375566 + fishPosX, 35.024176+s, 0.0);
   glVertex3f(20.21639 + fishPosX, 74.022232+s, 0.0);
   glVertex3f(39.95418 + fishPosX, 54.28444+s, 0.0);
   glEnd();

   // Triangle 2
   glColor3f(1.0, 0.56, 0.0); // Orange
   glBegin(GL_TRIANGLES);
   glVertex3f(39.95418 + fishPosX, 54.28444+s, 0.0);
   glVertex3f(59.37362 + fishPosX, 73.70389+s, 0.0);
   glVertex3f(59.055268 + fishPosX, 35.024176+s, 0.0);
   glEnd();

   // Triangle 3
   glColor3f(0.87, 0.43, 0.63); // Pink
   glBegin(GL_TRIANGLES);
   glVertex3f(59.37362 + fishPosX, 73.70389+s, 0.0);
   glVertex3f(78.792 + fishPosX, 54.125264+s, 0.0);
   glVertex3f(59.055268 + fishPosX, 35.024176+s, 0.0);
   glEnd();

   // Triangle 4
   glColor3f(0.4, 0.72, 0.41); // Green
   glBegin(GL_TRIANGLES);
   glVertex3f(48.072143 + fishPosX, 62.561576+s, 0.0);
   glVertex3f(39.635829 + fishPosX, 93.44167+s, 0.0);
   glVertex3f(59.37362 + fishPosX, 73.70389+s, 0.0);
   glEnd();

   // Triangle 5
   glColor3f(0.93, 0.78, 0.31); // Yellow
   glBegin(GL_TRIANGLES);
   glVertex3f(48.072143 + fishPosX, 46.166477+s, 0.0);
   glVertex3f(40.0 + fishPosX, 16.0+s, 0.0);
   glVertex3f(59.055268 + fishPosX, 35.024176+s, 0.0);
   glEnd();

   glFlush();
}


void update(int value) {
    jellyPosY += 5.0;
    if (jellyPosY > 1050){
    jellyPosY = 0;
    }
    fishPosX2 -= 5.0;
    if (fishPosX2 < 0){
    fishPosX2 = windowWidth-200;
    }
   fishPosX += 5.0; // Move the fish to the right by 10 units
   if (fishPosX > 1800.0)
      fishPosX = 50.0; // Reset the fish position if it goes off-screen

   glutPostRedisplay();
   glutTimerFunc(30, update, 0); // Call the update function after 100 milliseconds
}
void drawGrass()
{
    // Define colors for different layers of grass
    GLfloat darkGreen[] = { 0.0f, 0.392f, 0.0f };
    GLfloat lightGreen[] = { 0.0f, 0.749f, 0.0f };

    // Draw multiple layers of grass with varying heights
    for (int j = 0; j < 2; j++) {
        glColor3fv(j == 0 ? darkGreen : lightGreen);
        glLineWidth(2.0f - j);

        // Draw grass using lines and curves
        for (int i = 50; i < 1870; i += 10) {
            glBegin(GL_LINES);
            glVertex2f(i, 0.0f);
            glVertex2f(i + 5, 30.0f - j * 10);
            glEnd();

            glBegin(GL_LINES);
            glVertex2f(i + 5, 30.0f - j * 10);
            glVertex2f(i + 10, 0.0f);
            glEnd();

            glBegin(GL_LINES);
            glVertex2f(i + 5, 30.0f - j * 10);
            glVertex2f(i + 5, 50.0f - j * 10);
            glEnd();

            glBegin(GL_LINES);
            glVertex2f(i + 2, 0.0f);
            glVertex2f(i + 3, 15.0f - j * 5);
            glEnd();

            glBegin(GL_LINES);
            glVertex2f(i + 8, 0.0f);
            glVertex2f(i + 7, 15.0f - j * 5);
            glEnd();

            glBegin(GL_LINES);
            glVertex2f(i + 3, 15.0f - j * 5);
            glVertex2f(i + 5, 20.0f - j * 5);
            glEnd();

            glBegin(GL_LINES);
            glVertex2f(i + 7, 15.0f - j * 5);
            glVertex2f(i + 5, 20.0f - j * 5);
            glEnd();

            // Draw additional lines to make the grass appear denser and more realistic
            glBegin(GL_LINES);
            glVertex2f(i, 0.0f);
            glVertex2f(i + 3, 20.0f - j * 8);
            glEnd();

            glBegin(GL_LINES);
            glVertex2f(i + 3, 20.0f - j * 8);
            glVertex2f(i + 6, 0.0f);
            glEnd();

            glBegin(GL_LINES);
            glVertex2f(i + 2, 0.0f);
            glVertex2f(i + 4, 20.0f - j * 8);
            glEnd();

            glBegin(GL_LINES);
            glVertex2f(i + 4, 20.0f - j * 8);
            glVertex2f(i + 7, 0.0f);
            glEnd();

            glBegin(GL_LINES);
            glVertex2f(i + 1, 0.0f);
            glVertex2f(i + 5, 18.0f - j * 7);
            glEnd();

            glBegin(GL_LINES);
            glVertex2f(i + 5, 18.0f - j * 7);
            glVertex2f(i + 9, 0.0f);
            glEnd();
        }
    }
}
void drawAquarium()
{
    glClear(GL_COLOR_BUFFER_BIT);

    // Draw aquarium
    glColor3f(0.678f, 0.847f, 0.902f);
    glBegin(GL_POLYGON);
    glVertex2f(0.0f, 0.0f);
    glVertex2f(0.0f, 1080.0f);
    glVertex2f(1920.0f, 1080.0f);
    glVertex2f(1920.0f, 0.0f);
    glEnd();

    // Draw left border
    glColor3f(0.282f, 0.239f, 0.545f);  // White color
    glBegin(GL_POLYGON);
    glVertex2f(0.0f, 0.0f);
    glVertex2f(50.0f, 0.0f);
    glVertex2f(50.0f, 1080.0f);
    glVertex2f(0.0f, 1080.0f);
    glEnd();

    // Draw right border
    glBegin(GL_POLYGON);
    glVertex2f(1870.0f, 0.0f);
    glVertex2f(1920.0f, 0.0f);
    glVertex2f(1920.0f, 1080.0f);
    glVertex2f(1870.0f, 1080.0f);
    glEnd();

    glBegin(GL_POLYGON);
    glVertex2f(0.0f, 0.0f);
    glVertex2f(1920.0f, 0.0f);
    glVertex2f(1920.0f, 50.0f);
    glVertex2f(0.0f, 50.0f);
    glEnd();
    glPushMatrix();
    glTranslatef(0.0f, 50.0f, 0.0f);
    drawGrass();
    glPopMatrix();
    glFlush();
}
void drawBubbles() {

   // Draw water bubbles as outlined circles
   glColor3f(1.0, 1.0, 1.0);
   glPointSize(1.0);
   glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); // Enable only stroke color

   // Draw the stream of bubbles from a specific point
   int streamX = 250;
   int streamY = 100;

   for (int i = 0; i < numBubbles; ++i) {
      glPushMatrix();
      glTranslatef(bubblePositionX[i], bubblePositionY[i], 0.0);

      // Calculate the distance from the stream point
      float dx = bubblePositionX[i] - streamX;
      float dy = bubblePositionY[i] - streamY;
      float distance = sqrt(dx * dx + dy * dy);

      // Adjust the bubble size based on the distance from the stream point
      float bubbleSize = bubbleRadius * (1.0 - distance / (windowHeight - streamY));

      glBegin(GL_POLYGON);
      for (int j = 0; j <= 360; j++) {
         float angle = j * 3.14159 / 180.0;
         float x = bubbleSize * cos(angle);
         float y = bubbleSize * sin(angle);
         glVertex2f(x, y);
      }
      glEnd();
      glPopMatrix();
   }

   glPolygonMode(GL_FRONT_AND_BACK, GL_FILL); // Restore fill mode
   glFlush();
}


void updateBubbles() {
   // Update bubble positions
   for (int i = 0; i < numBubbles; ++i) {
      bubblePositionY[i] += bubbleSpeed;

      // If bubble goes beyond the top of the aquarium, reset its position
      if (bubblePositionY[i] > windowHeight - 50) {
         bubblePositionX[i] = rand() % (windowWidth - 100) + 50;
         bubblePositionY[i] = 50;
      }

      // Check for overlap with other bubbles
      for (int j = 0; j < numBubbles; ++j) {
         // Skip the current bubble
         if (i == j) continue;

         // Calculate the distance between the bubbles
         float dx = bubblePositionX[i] - bubblePositionX[j];
         float dy = bubblePositionY[i] - bubblePositionY[j];
         float distance = sqrt(dx * dx + dy * dy);

         // If the distance is less than the sum of the bubble radii, adjust the position
         if (distance < 2 * bubbleRadius) {
            bubblePositionX[i] += (2 * bubbleRadius - distance) * dx / distance;
            bubblePositionY[i] += (2 * bubbleRadius - distance) * dy / distance;
         }
      }
   }
}
void init() {
   glClearColor(0.0, 0.0, 0.0, 0.0);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   gluOrtho2D(0.0, windowWidth, 0.0, windowHeight);

   // Initialize bubble positions
   for (int i = 0; i < numBubbles; ++i) {
      bubblePositionX[i] = rand() % (windowWidth - 100) + 50;
      bubblePositionY[i] = rand() % (windowHeight - 100) + 50;
   }
}
void display() {
   glClear(GL_COLOR_BUFFER_BIT);

   drawAquarium();
   drawBubbles();

    fish1(400);
    fish2(600);
    jellyfish();
   glutSwapBuffers();
}

void timer(int) {
   updateBubbles();
   glutPostRedisplay();
   glutTimerFunc(10, timer, 0);
}

int main(int argc, char** argv) {
   glutInit(&argc, argv);
   glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
   glutInitWindowSize(windowWidth, windowHeight);
   glutInitWindowPosition(100, 100);
   glutCreateWindow("Fish Aquarium with Water Bubbles");
   init();
   glutDisplayFunc(display);
   glutTimerFunc(10, timer, 0);
   glutTimerFunc(0, update, 0);
   glutMainLoop();
   return 0;
}
